###  Non-ideal LIF.  Assume slow random mod of firing rate:  AR1
###  also assume PSTH is slightly different from trial to trial
#
#    also assume there is fluctuation in avg. osc. freq for each trial

import numpy.polynomial.polynomial as _Npp
from mcmcARpPlot import plotWFandSpks
from shutil import copyfile
from utildirs import setFN
from kassdirs import resFN
import utilities as _U
from kflib import createFlucOsc, createDataAR, createOscPacket
import numpy as _N
import matplotlib.pyplot as _plt

setname="LIF-"
 #  dV = -V/(RC) + I/C
#  dV = -V/tau + I/C  = -V/tau + eps I

TR  = 120;   N   = 1000;   dt  = 0.001     #  1ms
trim=0;
ISItmscl = 300

tau = .2      #  ms.  time constant = 1/RC
bcksig =210   #  background firing 
rst   = 0
thr   = 1
xmultLo=0.1

lowQpc     = 0;        lowQs    = None
isis       = None;     
B          = None;     a        = None;      aNz      = None  #  spline
us         = None

oscCS      = None;    etme      = None;    #  oscCS coupling strength over trial
nPSTHs     = 1   # number of psths
psthTypsPc = None  # ratio of each psth tpe
psthThisTrial = None   # which psth is active for a given trial

nRhythms   = None;
rs         = None;     ths      = None;      alfa     = None;
thsVAR     = None;

bGenOscUsingAR = True;  bGenOscUsingSines = False;

updn       = None;   #  additive

#   These params if osc. not generated by AR but by Sines
f0VAR      = None;     f0         = None;     Bf         = None;     Ba       = None;      amp      = 1;   amp_nz  = 0;
dSA        = 5;     dSF        = 5;
#       dSA, dSF    modulations created like (AR / (dSX x stddev)).
#   Along with above parameters, if generating wave packet
oscLocus  = 0;    oscWidth  =  0

errH  = 0.004
errL  = 0.00001
obsnz= 1e-1

cand   = 1;    #  if we want to ensure relatively large amplitude waveforms, set this.   Pick strongest out of candidates
buff   = 200

def create(setname):
    global lowQs, lowQpc, f0VAR, oscCS, etme, xmultLo, updn, buff, thsVAR, a, B, Is, psthThisTrial, nPSTHs, psthTypsPc

    copyfile("%s.py" % setname, "%(s)s/%(s)s.py" % {"s" : setname, "to" : setFN("%s.py" % setname, dir=setname, create=True)})

    if etme is None:
        etme = _N.ones((TR, N))
    if updn is None:
        updn = _N.zeros((TR, N+buff))

    if bGenOscUsingAR:
        alfa     = _N.empty((TR, nRhythms, 2), dtype=_N.complex)
        if thsVAR is None:
            thsVAR   = _N.zeros((TR, nRhythms))

        for tr in xrange(TR):
            for nr in xrange(nRhythms):
                th = ths[nr] + thsVAR[tr, nr]
                alfa[tr, nr, 0] = rs[nr]*(_N.cos(th) + 1j*_N.sin(th))
                alfa[tr, nr, 1] = rs[nr]*(_N.cos(th) - 1j*_N.sin(th))

        ARcoeff = _N.empty((TR, nRhythms, 2))
        for tr in xrange(TR):
            for n in xrange(nRhythms):
                ARcoeff[tr, n]          = (-1*_Npp.polyfromroots(alfa[tr, n])[::-1][1:]).real
    elif bGenOscUsingSines:
        if f0VAR is None:
            f0VAR   = _N.zeros(TR)
        sig = 0.1
        x, y = createDataAR(100000, Bf, sig, sig)
        stdf  = _N.std(x)   #  choice of 4 std devs to keep phase monotonically increasing
        x, y = createDataAR(100000, Ba, sig, sig)
        stda  = _N.std(x)   #  choice of 4 std devs to keep phase monotonically increasing

    if oscCS is None:   #  coupling strength of osc. given
        oscCS = _N.ones(TR)

    V     = _N.empty(N+buff)


    dV    = _N.empty(N+buff)
    dN    = _N.zeros(N+buff)

    xprbsdN= _N.empty((N, 3*TR))
    isis  = []
    bGivenLowQs = True
    bGivenPSTHbyTrial = True
    if lowQs is None:
        lowQs = []
        bGivenLowQs = False
    if (psthTypsPc is None) or (nPSTHs == 1):
        bGivenPSTHbyTrial = False        
        psthThisTrial = _N.zeros(TR, dtype=_N.int)
        nknts = a.shape[0]
    else:
        crat = _N.zeros(len(psthTypsPc)+1)
        for ityp in xrange(len(psthTypsPc)):
            crat[ityp+1] = crat[ityp] + psthTypsPc[ityp]
        nknts = a.shape[1]
        psthThisTrial = _N.empty(TR, dtype=_N.int)
        for tr in xrange(TR):
            rnd = _N.random.rand()
            typ = _N.where((rnd > crat[0:-1]) & (rnd < crat[1:]))[0][0]
            psthThisTrial[tr] = typ

    spksPT= _N.empty(TR)

    currentsPSTH = _N.empty((N+buff, TR))
    currentsOsc = _N.empty((N+buff, TR))
    currentsUpDn = _N.empty((N+buff, TR))   #  slow up-downs

    for tr in xrange(TR):
        V[0]  = 0.1*_N.random.randn()
        eps = bcksig*_N.random.randn(N+buff)   # time series
        sTs   = []

        if bGenOscUsingAR:
            err = nzs[0, 1]
            
            if not bGivenLowQs:   #  randomly gen. trials which are lowQs
                if _N.random.rand() < lowQpc:
                    err = nzs[0, 0]
                    lowQs.append(tr)
            else:
                try:
                    lowQs.index(tr)
                    err = nzs[0, 0]
                except ValueError:
                    pass

            maxPwr = 0
            for i in xrange(cand):
                x, y= createDataAR(N, ARcoeff[tr, 0], err, obsnz, trim=trim)
                x *= etme[tr]
                pwr = _N.sum(x**2)
                if pwr > maxPwr:
                    xBest = x
                    maxPwr = pwr
        elif bGenOscUsingSines:
            xmult = 1
            if not bGivenLowQs:   #  randomly gen. trials which are lowQs
                if _N.random.rand() < lowQpc:
                    xmult = xmultLo
                    lowQs.append(tr)
            else:
                try:
                    lowQs.index(tr)
                    xmult = xmultLo
                except ValueError:
                    pass

            x = xmult*createFlucOsc(f0, _N.array([f0VAR[tr]]), N, dt, 1, Bf=Bf, Ba=Ba, amp=amp, amp_nz=amp_nz, stdf=stdf, stda=stda, sig=sig, smoothKer=5, dSA=dSA, dSF=dSF) * etme[tr]  # sig is arbitrary, but we need to keep it same as when stdf, stda measured
            _xBest = x[0]

        dN[:] = 0

        _psth    = _N.empty((nPSTHs, N))
        psth     = _N.empty((nPSTHs, N+buff))
        for np in xrange(nPSTHs):
            if nPSTHs == 1:
                _psth[np]  = _N.dot(B, a + aNz*_N.random.randn(nknts))
            else:
                _N.dot(B, a[np] + aNz*_N.random.randn(nknts))
                _psth[np]  = _N.dot(B, a[np] + aNz*_N.random.randn(nknts))
            psth[np]   = _N.empty(N+buff)
            psth[np, 0:buff] = _psth[np, 0]
            psth[np, buff:]  = _psth[np]
        xBest  = _N.empty(N+buff)
        xBest[0:buff] = 0#_xBest[0:buff][::-1]
        xBest[buff:]  = _xBest

        #etmeBUF   = _N.ones((TR, N+buff))
        #etmeBUF[:, buff:] = etme
        for n in xrange(N-1+buff):
            currentsPSTH[n, tr] = psth[psthThisTrial[tr], n]
            currentsOsc[n, tr] = xBest[n]
            currentsUpDn[n, tr] = updn[tr, n]

            dV[n] = -V[n] / tau + eps[n] + currentsPSTH[n, tr] + Is[tr] + oscCS[tr]*currentsOsc[n, tr]

            V[n+1] = V[n] + dV[n]*dt

            if V[n+1] + updn[tr, n] > thr:
                V[n + 1] = rst
                dN[n] = 1
                if n > buff:
                    sTs.append(n-buff)

        spksPT[tr] = len(sTs)

        xprbsdN[:, tr*3]     = xBest[buff:]
        xprbsdN[:, tr*3 + 1] = V[buff:]
        xprbsdN[:, tr*3 + 2] = dN[buff:]
        isis.extend(_U.toISI([sTs])[0])

    fmt = "%.3f  " * TR
    _N.savetxt(resFN("currentsPSTH.dat", dir=setname, create=True), currentsPSTH[buff:], fmt=fmt)
    fmt = "%.3f  "
    _N.savetxt(resFN("currentsIs.dat", dir=setname, create=True), Is, fmt=fmt)

    fmt = "%.3f  " * TR
    _N.savetxt(resFN("currentsUpDn.dat", dir=setname, create=True), currentsUpDn[buff:], fmt=fmt)
    fmt = "%.3f  " * TR
    _N.savetxt(resFN("currentsOsc.dat", dir=setname, create=True), currentsOsc[buff:], fmt=fmt)

    if bGivenLowQs:
        fmt = "%d"
        _N.savetxt(resFN("lowQs.dat", dir=setname, create=True), lowQs, fmt=fmt)
    if bGivenPSTHbyTrial:
        fmt = "%d"
        _N.savetxt(resFN("psthTyps.dat", dir=setname, create=True), psthThisTrial, fmt=fmt)


    fmt = "% .2e %.3f %d " * TR
    _N.savetxt(resFN("xprbsdN.dat", dir=setname, create=True), xprbsdN, fmt=fmt)

    if bGenOscUsingAR:
        plotWFandSpks(N-1, dN[buff:], [xBest[buff:]], sTitle="AR2 freq %(f).1fHz  num spks %(d).0f   spk Hz %(spkf).1fHz" % {"f" : (500*ths[0]/_N.pi), "d" : _N.sum(dN[buff:]), "spkf" : (_N.sum(dN[buff:]) / (N*0.001))}, sFilename=resFN("generative", dir=setname))
    else:
        plotWFandSpks(N-1, dN[buff:], [xBest[buff:]], sTitle="", sFilename=resFN("generative", dir=setname))

    fig = _plt.figure(figsize=(8, 4))
    _plt.hist(isis, bins=range(100), color="black")
    _plt.grid()
    _plt.savefig(resFN("ISIhist", dir=setname))
    _plt.close()

    cv = _N.std(spksPT)**2/_N.mean(spksPT)
    fig = _plt.figure(figsize=(13, 4))
    _plt.plot(spksPT, marker=".", color="black", ms=8)
    _plt.ylim(0, max(spksPT)*1.1)
    _plt.grid()
    _plt.suptitle("avg. Hz %(hz).1f   cv=%(cv).2f" % {"hz" : (_N.mean(spksPT) / (N*0.001)), "cv" : cv})

    _plt.savefig(resFN("spksPT", dir=setname))
    _plt.close()

    cv   = _N.std(isis) / _N.mean(isis)
    #fig  = _plt.figure(figsize=(7, 3.5))
    fig, ax  = _plt.subplots(figsize=(7, 8))
    _plt.subplot(2, 1, 1)
    _plt.hist(isis, bins=range(0, 50), color="black")
    _plt.grid()
    _plt.subplot(2, 1, 2)
    _plt.hist(isis, bins=range(0, ISItmscl), color="black")
    _plt.yscale("log")
    _plt.grid()
    _plt.suptitle("ISI cv %.2f" % cv)
    _plt.savefig(resFN("ISIhist", dir=setname))
    _plt.close()

