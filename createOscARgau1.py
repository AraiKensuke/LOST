import scipy.optimize as _sco
from shutil import copyfile
from utildirs import setFN
from mcmcARpPlot import plotWFandSpks
import matplotlib.pyplot as _plt

from kflib import createFlucOsc, createDataAR, createOscPacket
from kassdirs import resFN, datFN
import numpy as _N
import pickle as _pk
import warnings
import numpy.polynomial.polynomial as _Npp
import utilities as _U
from kstat import percentile

TR         = None;     N        = None;      dt       = 0.001
trim       = 50;
nzs        = None;     nRhythms = None;
rs         = None;     ths      = None;      alfa     = None;
obsNz      = 0


#   These params if osc. not generated by AR but by Sines
f0VAR      = None;     f0         = None;     Bf         = None;     Ba       = None;      amp      = 1;   amp_nz  = 0;
dSA        = 5;     dSF        = 5;

#   These params if osc. not generated by AR but by Sines
f0VAR_1      = None;   f0_1         = None;   Bf_1         = None;   Ba_1       = None;      amp_1      = 1; amp_nz_1  = 0;
dSA_1      = 5;     dSF_1      = 5;

def create(setname):
    copyfile("%s.py" % setname, "%(s)s/%(s)s.py" % {"s" : setname, "to" : setFN("%s.py" % setname, dir=setname, create=True)})
    global dt, lambda2, rpsth, isis, us, TR, etme, f0VAR

    nColumns = 3
    alldat  = _N.empty((N, TR*nColumns))
    for tr in xrange(TR):
        if f0VAR is None:
            f0VAR   = _N.zeros(TR)
        sig = 0.1
        x, y = createDataAR(100000, Bf, sig, sig)
        stdf  = _N.std(x)   #  choice of 4 std devs to keep phase monotonically increasing
        x, y = createDataAR(100000, Ba, sig, sig)
        stda  = _N.std(x)   #  choice of 4 std devs to keep phase monotonically increasing

        x, y = createDataAR(100000, Bf_1, sig, sig)
        stdf_1  = _N.std(x)   #  choice of 4 std devs to keep phase monotonically increasing
        x, y = createDataAR(100000, Ba_1, sig, sig)
        stda_1  = _N.std(x)   #  choice of 4 std devs to keep phase monotonically increasing

        x = createFlucOsc(f0, _N.array([f0VAR[tr]]), N, dt, 1, Bf=Bf, Ba=Ba, amp=amp, amp_nz=amp_nz, stdf=stdf, stda=stda, sig=sig, smoothKer=5, dSA=dSA, dSF=dSF)  # sig is arbitrary, but we need to keep it same as when stdf, stda measured
        x_1 = createFlucOsc(f0_1, _N.array([f0VAR_1[tr]]), N, dt, 1, Bf=Bf_1, Ba=Ba_1, amp=amp_1, amp_nz=amp_nz_1, stdf=stdf_1, stda=stda_1, sig=sig, smoothKer=5, dSA=dSA_1, dSF=dSF_1)  # sig is arbitrary, but we need to keep it same as when stdf, stda measured
        y = x[0, :] + x_1[0, :] + obsNz*_N.random.randn(N)
        alldat[:, tr*nColumns] = x
        alldat[:, tr*nColumns+1] = x_1
        alldat[:, tr*nColumns+2] = y

    fmtstr = "%.3f %.3f %.3f" * TR
    _N.savetxt(resFN("gauobs.dat", dir=setname), alldat, fmt=fmtstr)
    return alldat
